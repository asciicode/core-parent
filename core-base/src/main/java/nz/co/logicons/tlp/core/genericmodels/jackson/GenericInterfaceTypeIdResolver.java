package nz.co.logicons.tlp.core.genericmodels.jackson;


import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.reflections.Reflections;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.databind.DatabindContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.type.TypeFactory;

import nz.co.logicons.tlp.core.genericmodels.schemas.ChildSchema;
import nz.co.logicons.tlp.core.genericmodels.validators.Validator;
import nz.co.logicons.tlp.core.genericmodels.views.View;

/**
 * 
 * 
 * Would be nice to use the default type id generated by jackson (i.e the full name of the class)
 * Unfortunately our existing code (and more importantly schemas/views set up by Logicons in mongo write the short class
 * name in lower case as type (e.g searchview)
 * 
 * @author bhambr
 *
 */
public class GenericInterfaceTypeIdResolver implements TypeIdResolver
{

  private static Logger log = LoggerFactory.getLogger(GenericInterfaceTypeIdResolver.class);
  
  private static Map<Class<?>, Map<String, Class<?>>> classMap = new HashMap<Class<?>, Map<String,Class<?>>>();
  
  static
  {
    try
    {
      //use reflections to build up a map of subclasses for View and Schema.
      classMap.put(View.class, new HashMap<>());
      classMap.put(ChildSchema.class, new HashMap<>());
      classMap.put(Validator.class, new HashMap<>());
      
      Reflections reflections = new Reflections("nz.co.logicons.tlp.core");
      for (Class<?> clazz : classMap.keySet())
      {
        Map<String, Class<?>> subClassMap = classMap.get(clazz);
        for (Class<?> subClazz : reflections.getSubTypesOf(clazz))
        {
          subClassMap.put(subClazz.getSimpleName().toLowerCase(), subClazz);
        }
      }
    }
    catch (Exception e)
    {
      log.error("Unable to get subclasses", e);
    }
  }
  
  private JavaType mBaseType;
  
  @Override
  public void init(JavaType javaType)
  {javaType.getRawClass();
    mBaseType = javaType;
  }
  
  @Override
  public Id getMechanism()
  {
    return Id.CUSTOM;
  }

  @Override
  public String idFromBaseType()
  {
    return idFromValueAndType(null, mBaseType.getRawClass());
  }

  @Override
  public String idFromValue(Object obj)
  {
    return idFromValueAndType(obj, obj.getClass());
  }

  @Override
  public String idFromValueAndType(Object obj, Class<?> clazz)
  {
    //type written to json is the classname in lowercase.
    return clazz.getSimpleName().toLowerCase();
  }

  @Override
  public JavaType typeFromId(DatabindContext context, String id)
    throws IOException
  {
    // translate type from json into concrete class.
    Class<?> clazz = classMap.get(mBaseType.getRawClass()).get(id);
    return TypeFactory.defaultInstance().constructSpecializedType(mBaseType, clazz);
  }

  @Override
  public String getDescForKnownTypeIds()
  {
    return this.toString() + "getDescForKnownTypeIds method";
  }
  // @Override
  // public JavaType typeFromId(String type)
  // {
  // //translate type from json into concrete class.
  // Class<?> clazz = classMap.get(mBaseType.getRawClass()).get(type);
  // return TypeFactory.defaultInstance().constructSpecializedType(mBaseType, clazz);
  // }
}
